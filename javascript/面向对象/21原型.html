<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <script type="text/javascript">

        /**
         * 
         * 原型 prototype
         *  我们所创建的每一个函数，解析器都会向函数添加一个属性prototype
         *  这个属性对应着一个对象，这个对象就是原型对象
         * 
         * 如果函数作为普通函数调用prototype没有任何作用
         * 当函数以构造函数形式调用时，它创建的对象中都会有一个隐含的属性
         * 指向该构造函数的原型对象，可以通过_proto_来访问该属性
         * 
         * 
         * 原型对象相当于一个公共的区域，所有同一个类的实例都可以
         * 访问到这个原型对象，我们可以将对象中共有的内容，统一设置
         * 到原型对象中
         *  
         * 当我们访问对象的一个属性或方法时，没有时会去
         * 原型对象中寻找
         * 
        */

        function MyClass() {

        }
        // MyClass的原型中添加属性a
        MyClass.prototype.a = 123;
        MyClass.prototype.sayHello = function() {
            console.log('hello');
        }

        var mc = new MyClass();
        var mc2 = new MyClass();
        console.log(mc.__proto__ == MyClass.prototype);

        console.log(mc.a);
        mc.sayHello();

        console.log("a" in mc);
        // 该方法会检查对象自身（不包含原型）是否含有属性
        console.log(mc.hasOwnProperty("hasOwnProperty"));
        console.log(mc.hasOwnProperty("hasOwnProperty"));

        /**
         * 
         *  原型对象也是对象，所以它也有原型，
         *  我们使用一个对象的属性或方法，先在自身中
         *  寻找，如果没有则去原型对象中寻找，
         *  如果没有则去原型的原型中寻找，直到
         *  找到Object对象的原型
         *  Object对象的原型没有原型，如果没有，返回undefined
         * 
        */
        console.log(mc.__proto__.__proto__.hasOwnProperty("hasOwnProperty"));


        // js垃圾回收，浏览器自动回收，我们将不再使用的对象设置为null

    </script>
 

</head>
<body>
    
</body>
</html>